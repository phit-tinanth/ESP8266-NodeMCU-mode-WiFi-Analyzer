# ESP8266-NodeMCU-mode-WiFi-Analyzer
ตัววิเคราะห์ WiFi เป็นเครื่องมือที่สามารถใช้ในการวิเคราะห์และเพิ่มประสิทธิภาพของเครือข่ายไร้สาย สามารถช่วยคุณระบุปัญหาเกี่ยวกับสัญญาณ WiFi ของคุณเช่นสัญญาณรบกวนความแออัดของเครือข่ายและความแรงของสัญญาณต่ําและแนะนําวิธีแก้ไขเพื่อปรับปรุงประสิทธิภาพของเครือข่ายของคุณ

## ESP8266-NodeMCU-mode-WiFi-Analyzer
บรรทัดของโค้ดเหล่านี้จะกําหนดมาโครที่ควบคุมชนิดของการแสดงผล TFT ที่จะใช้ในแบบร่าง จอแสดงผล TFT เป็น LCD ประเภทหนึ่ง (จอแสดงผลคริสตัลเหลว) ที่ใช้ในอุปกรณ์อิเล็กทรอนิกส์จํานวนมากเพื่อแสดงข้อความและกราฟิก

มาโครแต่ละตัวสอดคล้องกับจอแสดงผล TFT ประเภทต่าง ๆ และมีเพียงตัวเดียวเท่านั้นที่ถูกกําหนดให้เป็น "ใช้งานอยู่" โดยการลบสัญลักษณ์ "//" (ความคิดเห็น) ที่อยู่ข้างหน้า ภาพร่างจะถูกคอมไพล์ด้วยรหัสเฉพาะสําหรับจอแสดงผล TFT ประเภทนั้น

ตัวอย่างเช่น หากบรรทัด "#define ST7735_144GREENTAB" ทํางานอยู่ (เช่น ไม่ได้แสดงความคิดเห็น) ภาพร่างจะถูกคอมไพล์ด้วยโค้ดเฉพาะสําหรับจอแสดงผล ST7735 ซึ่งมีความละเอียด 128x128 พิกเซล และใช้ในจอแสดงผลรุ่น "แท็บสีเขียว" หากมีการใช้ประเภทการแสดงผลที่แตกต่างกันเช่น ILI9341 ควรกําหนดมาโครที่เกี่ยวข้องแทน


## เลือก library

```C++
//#define ILI9341
//#define ST7735_18GREENTAB
//#define ST7735_18REDTAB
//#define ST7735_18GBLACKTAB
#define ST7735_144GREENTAB
```
## นี่คือฟังก์ชั่นของภาพร่าง Arduino

ที่ดูเหมือนจะเริ่มต้นและตั้งค่าจอแสดงผล TFT และการเชื่อมต่อ WiFisetup()

ส่วนแรกของฟังก์ชันกําหนดลักษณะการทํางานของพินไฟ LCD และพินไฟ LED ขึ้นอยู่กับว่ามีการใช้ทรานซิสเตอร์ PNP เพื่อควบคุมพลังงานหรือไม่ หากกําลังใช้ทรานซิสเตอร์ PNP ฟังก์ชันจะตั้งค่าพินพลังงาน LCD เป็นเอาต์พุตและตั้งค่าเป็น LOW เพื่อเปิดเครื่อง หากไม่ได้ใช้ทรานซิสเตอร์ PNP ฟังก์ชันจะตั้งค่าทั้งพินพลังงาน LCD และพินไฟ LED เป็นเอาต์พุตและตั้งค่าเป็น HIGH เพื่อเปิดเครื่อง

ฟังก์ชันนี้จะเริ่มต้นการแสดงผล TFT โดยใช้รูทีนการเริ่มต้นเฉพาะตามประเภทของจอแสดงผล TFT ที่ใช้ จากนั้นตั้งค่าการหมุนของจอแสดงผลเป็น 3 และเติมหน้าจอด้วยสีน้ําเงิน

จากนั้นฟังก์ชันจะกําหนดขนาดข้อความและสีข้อความของพื้นที่แบนเนอร์ที่ด้านบนของหน้าจอและพิมพ์ข้อความแบนเนอร์โดยใช้ฟังก์ชันของไลบรารี TFTprint()

สุดท้ายฟังก์ชันจะตั้งค่าโหมด WiFi เป็นโหมดสถานี (WIFI_STA) และตัดการเชื่อมต่อจากจุดเชื่อมต่อ (AP) ที่เชื่อมต่อก่อนหน้านี้ จากนั้นจะรอ 100 มิลลิวินาที () ก่อนดําเนินการต่อdelay(100)

```c++
void setup();
```
##ฟังก์ชั่นทําการสแกน WiFi 

โดยใช้ ซึ่งส่งคืนจํานวนเครือข่ายที่พบ หากไม่พบเครือข่าย จะมีการพิมพ์ข้อความบนจอแสดงผลเพื่อระบุสิ่งนี้ หากพบเครือข่าย ลูปจะวนซ้ําในแต่ละเครือข่าย รับช่องสัญญาณ ความแรงของสัญญาณ (RSSI) และประเภทการเข้ารหัส จากนั้นจะพล็อตข้อมูลนี้บนจอแสดงผลวาดเส้นที่แสดงถึงความแรงของสัญญาณสําหรับแต่ละเครือข่ายในช่องสัญญาณที่เหมาะสมloop()WiFi.scanNetworks()

รหัสยังติดตามสถิติเกี่ยวกับเครือข่ายที่พบรวมถึงจํานวนเครือข่ายที่พบในแต่ละช่องและความแรงของสัญญาณสูงสุดที่เห็นในแต่ละช่อง หลังจากลูปประมวลผลเครือข่ายทั้งหมดเสร็จแล้วรหัสจะใช้ข้อมูลนี้เพื่อแนะนําว่าช่องสัญญาณใดเหมาะที่สุดสําหรับเครือข่ายไร้สายโดยพิจารณาจากการมีอยู่ของเครือข่ายอื่นและความแรงของสัญญาณ

สุดท้ายรหัสจะวาดเส้นแนวนอนบนจอแสดงผลเพื่อใช้เป็นฐานของกราฟและติดป้ายกํากับแต่ละช่องด้วยหมายเลข
```c++
void loop()
```


uint8_t ap_count[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; ประกาศอาร์เรย์ของ 14 องค์ประกอบประเภท ซึ่งเป็นชนิดจํานวนเต็ม 8 บิตที่ไม่ได้ลงชื่อ แต่ละองค์ประกอบในอาร์เรย์จะถูกเตรียมใช้งานเป็น 0 อาร์เรย์นี้จะถูกใช้เพื่อติดตามจํานวนเครือข่ายที่พบในแต่ละช่องสัญญาณระหว่างการสแกน WiFiuint8_t

int32_t max_rssi[] = {-100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100}; ประกาศอาร์เรย์ของ 14 องค์ประกอบของชนิด ซึ่งเป็นชนิดจํานวนเต็ม 32 บิตที่เซ็นชื่อ แต่ละองค์ประกอบในอาร์เรย์จะถูกเตรียมใช้งานเป็น -100 อาร์เรย์นี้จะถูกใช้เพื่อติดตามความแรงของสัญญาณสูงสุด (RSSI) ที่เห็นในแต่ละช่องสัญญาณระหว่างการสแกน WiFiint32_t

```c++
    uint8_t ap_count[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int32_t max_rssi[] = {-100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100};
```

เป็นคําสั่งที่เรียกการทํางานของไลบรารี WiFi ฟังก์ชันนี้จะสแกนหาเครือข่ายไร้สายที่อยู่ใกล้เคียงและส่งกลับจํานวนเครือข่ายที่พบ ค่าที่ส่งกลับโดยฟังก์ชันจะถูกเก็บไว้ในตัวแปร ซึ่งเป็น (จํานวนเต็ม 32 บิตที่ลงชื่อแล้ว)scanNetworks()scanNetworks()nint

ฟังก์ชันนี้ทําการสแกนหาเครือข่ายไร้สายและส่งกลับจํานวนเครือข่ายที่พบ นอกจากนี้ยังเติมบัฟเฟอร์ภายในด้วยข้อมูลเกี่ยวกับแต่ละเครือข่ายเช่น SSID (ชื่อ) ความแรงของสัญญาณ (RSSI) และประเภทการเข้ารหัส ข้อมูลนี้สามารถเข้าถึงได้โดยใช้ฟังก์ชั่นอื่น ๆ ของไลบรารี WiFi เช่น , และ ดัชนีของเครือข่ายในบัฟเฟอร์ภายในอยู่ที่ไหนscanNetworks()WiFi.SSID(i)WiFi.RSSI(i)WiFi.encryptionType(i)i

```c++
int n = WiFi.scanNetworks();
```

บรรทัดแรกจะล้างจอแสดงผลโดยการวาดสี่เหลี่ยมผืนผ้าสีดําทั่วทั้งจอแสดงผล  คือวัตถุที่แสดงถึงจอแสดงผลและเป็นฟังก์ชันที่วาดสี่เหลี่ยมผืนผ้าที่เติมไว้บนจอแสดงผล อาร์กิวเมนต์เพื่อระบุพิกัด x และ y ของมุมบนซ้ายของสี่เหลี่ยมผืนผ้า ความกว้างและความสูงของสี่เหลี่ยมผืนผ้า และสีที่จะใช้เมื่อวาดสี่เหลี่ยมผืนผ้าtft.fillRect(0, BANNER_HEIGHT, 320, 224, TFT_BLACK);tftfillRect()fillRect()

เส้นจะกําหนดขนาดข้อความที่จะใช้เมื่อพิมพ์ข้อความบนจอแสดงผลเป็น 1tft.setTextSize(1);

หากจํานวนเครือข่ายที่พบระหว่างการสแกนเป็น 0 () จะมีการพิมพ์ข้อความบนจอแสดงผลเพื่อระบุว่าไม่พบเครือข่าย เส้นจะตั้งค่าสีข้อความที่จะใช้เมื่อพิมพ์ข้อความ และกําหนดตําแหน่งที่จะพิมพ์ข้อความบนจอแสดงผล เส้นจะพิมพ์ข้อความบนจอแสดงผลn == 0tft.setTextColor(TFT_BLACK);tft.setCursor(0, BANNER_HEIGHT);tft.println("no networks found");

หากพบเครือข่ายระหว่างการสแกน () รหัสจะเข้าสู่ลูปที่วนซ้ําในแต่ละเครือข่าย สําหรับแต่ละเครือข่ายจะได้รับช่องสัญญาณความแรงของสัญญาณ (RSSI) และประเภทการเข้ารหัสโดยใช้ฟังก์ชัน , และ ดัชนีของเครือข่ายในบัฟเฟอร์ภายในอยู่ที่ไหนn > 0WiFi.channel(i)WiFi.RSSI(i)WiFi.encryptionType(i)i

จากนั้นรหัสจะใช้ค่าเหล่านี้เพื่อพล็อตความแรงของสัญญาณของเครือข่ายบนจอแสดงผลและพิมพ์ SSID ความแรงของสัญญาณและประเภทการเข้ารหัสของเครือข่าย นอกจากนี้ยังอัปเดตและอาร์เรย์ด้วยข้อมูลของเครือข่ายปัจจุบัน สุดท้ายจะแทรกความล่าช้า 10 มิลลิวินาทีเพื่อให้กิจวัตร WiFi ทํางานอื่น ๆap_countmax_rssi


```c++
// clear old graph
    tft.fillRect(0, BANNER_HEIGHT, 320, 224, TFT_BLACK);
    tft.setTextSize(1);

    if (n == 0) {
        tft.setTextColor(TFT_BLACK);
        tft.setCursor(0, BANNER_HEIGHT);
        tft.println("no networks found");
    }
    else {
        // plot found WiFi info
        for (int i = 0; i < n; i++) {
            int32_t channel = WiFi.channel(i);
            int32_t rssi = WiFi.RSSI(i);
            uint16_t color = channel_color[channel - 1];
            int height = constrain(map(rssi, RSSI_FLOOR, RSSI_CEILING, 1, GRAPH_HEIGHT), 1, GRAPH_HEIGHT);

            // channel stat
            ap_count[channel - 1]++;
            if (rssi > max_rssi[channel - 1]) {
                max_rssi[channel - 1] = rssi;
            }

            tft.drawLine(channel * CHANNEL_WIDTH, GRAPH_BASELINE - height, (channel - 1) * CHANNEL_WIDTH, GRAPH_BASELINE + 1, color);
            tft.drawLine(channel * CHANNEL_WIDTH, GRAPH_BASELINE - height, (channel + 1) * CHANNEL_WIDTH, GRAPH_BASELINE + 1, color);

            // Print SSID, signal strengh and if not encrypted
            tft.setTextColor(color);
            tft.setCursor((channel - 1) * CHANNEL_WIDTH, GRAPH_BASELINE - 10 - height);
            tft.print(WiFi.SSID(i));
            tft.print('(');
            tft.print(rssi);
            tft.print(')');
            if (WiFi.encryptionType(i) == ENC_TYPE_NONE) {
                tft.print('*');
            }

            // rest for WiFi routine?
            delay(10);
        }
    }
```

รหัสนี้กําลังพิมพ์ข้อมูลเกี่ยวกับเครือข่ายไร้สายที่พบในระหว่างการสแกน และแนะนําว่าช่องสัญญาณใดอาจเป็นตัวเลือกที่ดีสําหรับใช้ในเครือข่ายไร้สาย

เส้นจะตั้งค่าสีข้อความที่จะใช้เมื่อพิมพ์ข้อมูล และกําหนดตําแหน่งที่จะพิมพ์ข้อความบนจอแสดงผลtft.setTextColor(TFT_WHITE);tft.setCursor(0, BANNER_HEIGHT);

เส้นจะพิมพ์จํานวนเครือข่ายที่พบระหว่างการสแกน บรรทัดจะพิมพ์ข้อความที่ระบุว่าข้อความต่อไปนี้จะเป็นรายการของแชนเนลที่แนะนําtft.print(n);tft.print(" networks found, suggested channels: ");

จากนั้นรหัสจะเข้าสู่ลูปที่วนซ้ําใน 11 ช่องแรก (ช่อง 12-14 อาจไม่พร้อมใช้งาน) สําหรับแต่ละช่องจะตรวจสอบความแรงของสัญญาณของช่องสัญญาณก่อนหน้าและถัดไปและมีเครือข่ายใด ๆ ในช่องสัญญาณปัจจุบันหรือไม่ หากความแรงของสัญญาณของช่องสัญญาณก่อนหน้าและถัดไปต่ํากว่าเกณฑ์ที่กําหนด () และไม่มีเครือข่ายบนช่องสัญญาณปัจจุบันรหัสจะพิมพ์หมายเลขช่องสัญญาณเป็นช่องที่แนะนํา นอกจากนี้ยังเพิ่มเครื่องหมายจุลภาคระหว่างหมายเลขช่องหากนี่ไม่ใช่ช่องแรกที่แสดงอยู่NEAR_CHANNEL_RSSI_ALLOW

สุดท้ายรหัสจะตั้งค่าสถานะ () เป็นเมื่อพิมพ์ช่องแรกแล้วเพื่อให้ช่องที่ตามมาจะถูกคั่นด้วยเครื่องหมายจุลภาคlisted_first_channeltrue

```c++
// print WiFi stat
    tft.setTextColor(TFT_WHITE);
    tft.setCursor(0, BANNER_HEIGHT);
    tft.print(n);
    tft.print(" networks found, suggested channels: ");
    bool listed_first_channel = false;
    for (int i = 1; i <= 11; i++) { // channels 12-14 may not available
        if ((i == 1) || (max_rssi[i - 2] < NEAR_CHANNEL_RSSI_ALLOW)) { // check previous channel signal strengh
            if ((i == sizeof(channel_color)) || (max_rssi[i] < NEAR_CHANNEL_RSSI_ALLOW)) { // check next channel signal strengh
                if (ap_count[i - 1] == 0) { // check no AP exists in same channel
                    if (!listed_first_channel) {
                        listed_first_channel = true;
                    }
                    else {
                        tft.print(", ");
                    }
                    tft.print(i);
                }
            }
        }
    }
```

 รหัสนี้วาดเส้นแนวนอนบนจอแสดงผลเพื่อใช้เป็นฐานของกราฟและติดฉลากแต่ละช่องด้วยหมายเลข

เส้นจะวาดเส้นแนวนอนสีขาวบนจอแสดงผลโดยเริ่มต้นที่ x=0, y= และขยายเป็น x=320  เป็นฟังก์ชันของไลบรารีการแสดงผลที่วาดเส้นแนวนอนอย่างรวดเร็วโดยการวาดโดยตรงไปยังบัฟเฟอร์หน่วยความจําของจอแสดงผลtft.drawFastHLine(0, GRAPH_BASELINE, 320, TFT_WHITE);GRAPH_BASELINEdrawFastHLine()

จากนั้นรหัสจะเข้าสู่ลูปที่วนซ้ําผ่าน 14 ช่อง สําหรับแต่ละแชนเนลจะตั้งค่าสีข้อความเป็นสีที่เกี่ยวข้องกับช่องนั้น () ตั้งค่าตําแหน่งเคอร์เซอร์ให้อยู่ในตําแหน่งใกล้กับกึ่งกลางของช่องและพิมพ์หมายเลขช่องchannel_color[i - 1]

หากมีเครือข่ายใด ๆ ที่พบในช่องสัญญาณปัจจุบันรหัสจะพิมพ์จํานวนเครือข่ายที่พบในช่องด้านล่างหมายเลขช่อง จะปรับตําแหน่งเคอร์เซอร์ไปทางซ้ายหรือขวาขึ้นอยู่กับว่าจํานวนเครือข่ายเป็นตัวเลขหนึ่งหรือสองหลัก

```c++
    // draw graph base axle
    tft.drawFastHLine(0, GRAPH_BASELINE, 320, TFT_WHITE);
    for (int i = 1; i <= 14; i++) {
        tft.setTextColor(channel_color[i - 1]);
        tft.setCursor((i * CHANNEL_WIDTH) - ((i < 10)?3:6), GRAPH_BASELINE + 2);
        tft.print(i);
        if (ap_count[i - 1] > 0) {
            tft.setCursor((i * CHANNEL_WIDTH) - ((ap_count[i - 1] < 10)?9:12), GRAPH_BASELINE + 11);
            tft.print('(');
            tft.print(ap_count[i - 1]);
            tft.print(')');
        }
    }
 ```

รหัสนี้ดูเหมือนจะเป็นส่วนหนึ่งของลูปหลักของโปรแกรมที่สแกนหาเครือข่ายไร้สายใกล้เคียงและแสดงผลลัพธ์บนจอแสดงผล

เส้นแทรกการหน่วงเวลา 5,000 มิลลิวินาที (5 วินาที) ก่อนการทําซ้ําครั้งต่อไปของลูป สิ่งนี้ช่วยให้รูทีน WiFi ทํางานอื่น ๆ และเปิดโอกาสให้ผู้ใช้ดูข้อมูลบนจอแสดงผลdelay(5000);

จากนั้นรหัสจะเพิ่มตัวนับ () และตรวจสอบว่าถึงค่าที่กําหนดหรือไม่ () หากตัวนับถึงเกณฑ์รหัสจะเข้าสู่โหมดประหยัดพลังงานโดยการปิดใช้งานพินบางตัวและทําให้ ESP32 (ไมโครคอนโทรลเลอร์ที่รันโปรแกรม) เข้าสู่โหมดสลีปลึก วิธีนี้ช่วยให้อุปกรณ์ใช้พลังงานน้อยลงเมื่อไม่ได้สแกนหาเครือข่ายscan_countSCAN_COUNT_SLEEP

```c++
    // Wait a bit before scanning again
    delay(5000);

    //POWER SAVING
    if (++scan_count >= SCAN_COUNT_SLEEP) {
        #if defined(PNP_PWR_TRANSISTOR)
            pinMode(LCD_PWR_PIN, INPUT);   // disable pin
        #else
            pinMode(LCD_PWR_PIN, INPUT);   // disable pin
            pinMode(LED_PWR_PIN, INPUT);   // disable pin
        #endif
            ESP.deepSleep(0);
    }
}
```
